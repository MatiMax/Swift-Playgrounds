/**
 Name:      QR Code iOS.playground
 Purpose:   Generate a QR code from a text string and copy it to the clipboard, adapted for iPadOS and iOS.
 Version:   1.0 (01-05-2020)
 Language:  Swift
 Author:    Matthias M. Schneider & Paul Hudson
 Copyright: IDC (I don't care)
 */
/*:
 # Introduction to `CoreImage` filters with QR code
 This playground not only shows you how to generate a QR code, but also sheds a little light on the possibility to scale such a bitmap without antialiasing or interpolation. It also implents a simple, but not perfect `MagnificationGesture` as well as a `TapGesture` which copies the QR code to the clipboard for pasting it in other apps.
 */
import SwiftUI
import CoreImage
import CoreImage.CIFilterBuiltins
import PlaygroundSupport
/*:
 # Components of the UI
 The playground uses the `QRView` which is composed of a verical arrangement of
 - a `TextField` for inputting the string which gets encoded as a QR code, and
 - an `Image` which displays the QR code.
 
 - Note:
 There is some visual sugar involved in presenting these two main components, like `Text`, a `RoundedRectangle` and a `Spacer`, so please investigate the view in detail to learn how the components are built.
 */
struct QRView: View {
//: We use a `@State` variable to track the encoded message and a `@State` variable for the scale of the QR code bitmap.
    @State private var message = "Hello, Swift!"
    @State private var scaleQR: CGFloat = 1
    
    var body: some View {
        VStack {
//: This `HStack` arranges a label and an input text field, which is decorated by a rounded rectangle. Watch out for the `overlay` modifier and mark the order of the overlaid components.
            HStack {
                Text("QR Code String")
                    .font(.system(size: 12))
                    .foregroundColor(.accentColor)
                RoundedRectangle(cornerRadius: 10)
                    .fill(Color.secondary).opacity(0.3)
                    .frame(height: 36)
                    .overlay(
                        TextField("Enter text", text: $message)
                            //.textFieldStyle(RoundedBorderTextFieldStyle())
                            .padding(6))
            }
            Spacer()
            Text("QR Code")
                .font(.system(size: 24))
                .foregroundColor(.accentColor)
            
//: This `Image` displays the actual QR code which gets generated by the `qrCodeGenerated` function.
            Image(uiImage: qrCodeGenerator().uiImage)
                .interpolation(.none) // Turn off anti-aliasing when scaling up or down
                .resizable()          // The image can be resized
                .scaledToFit()        // Always scale the image to fit the frame
                .scaleEffect(scaleQR) // Scale the image using the `scaleQR` state
                .gesture(MagnificationGesture()
                    .onChanged() { scale in self.scaleQR = scale }
            )
                
/*:
 ## Excursion to the representations of imagable data
 This is an attempt to explain why this playground uses a `CIImage` as a proxy to the QR code which gets placed onto the clipboard.
 ### Who should provide the image data?
 Before we can place a copy of the QR code onto the clipboad using the `UIPasteboard.general.image` property we have to grab the image data from somewhere.
 An instance of `Image` represents a view but not the actual image itself — it doesn't supply any function or property to read the image its view represents.
 Although `UIImage` does supply us with image data representations in form of `CGImage` and `CIImage` there is a caveat. Unfortunately, when creating a `UIImage` from a `CGImage` — like we do when creating the QR code — this `UIImage` does not represent itself implicitly by a `CIImage`; when you read its `ciImage` property the value will be `nil`.
 This is where the second value of the returned tuple of the `qrCodeGenerator` function comes into play. Why we actually *need* a `CIImage` will be explaied in the next section.
 ### How should we scale an image?
 The `Image` view provides some nice instance methods for scaling the image's content, like `imageScale`, `scaleEffect` and `transformEffect`. The problem is that the `Image` view does **not** expose its image to the outside world, so we cannot steal the rendered image from the view.
 Also, `UIImage` does not provide any direct means of scaling or transforming an image.
 Instead we use the `ciImage` value of the returned tuple of the `qrCodeGenerator` function for a scaled version of the QR code to be put onto the clipboard without any interpolation or anti-aliasing by creating a `UIImage` from it.
 */
                .onTapGesture {
/*:
 Use the following expressions in the playground to test the image representations:

     self.qrCodeGenerator().uiImage
     self.qrCodeGenerator().uiImage.cgImage
     self.qrCodeGenerator().uiImage.ciImage
     self.qrCodeGenerator().ciImage
 */
                    if let img = self.qrCodeGenerator().ciImage {
                        UIPasteboard.general.image = UIImage(ciImage: img.transformed(by: CGAffineTransform(scaleX: self.scaleQR *  8, y: self.scaleQR * 8)))
/*:
 And this does not work, either:
                         
     UIPasteboard.general.image = UIImage(cgImage: self.qrCodeGenerator()
                                      .uiImage.cgImage!, scale: self.scaleQR * 8, orientation: .up)
 */
                    }
            }
            .frame(width: 200, height: 200)
            .colorInvert()
            
            Text("Please scan to verify.")
            .font(.system(size: 12))
            .zIndex(-1)
        }
        .frame(width: 400, height: 400)
        .padding()
    }
    
/*:
 The function `qrCodeGenerator` produces a QR code from the `message` string using the according method on `CIFilter`. In order to make this work you have to
 - create a `CIContext`,
 - generate the QR code generator by calling the filter method, and
 - pass the message to be encoded.
 In order to use the QR code in SwiftUI's `Image` view we first need to generate a `CGImage` representation and then create a `UIImage` of it which is returned within a tuple.
 The function returns a tuple of both a `UIImage` and a `CIImage`, because only `CIImage` supports scaling without applying any interploation or anti-aliasing so that it can be used as source for placing it onto the clipboard.
 */
    func qrCodeGenerator() -> (uiImage: UIImage, ciImage: CIImage?) {
        let context = CIContext()
        let qrCode = CIFilter.qrCodeGenerator()
        let xMarkCircle = UIImage(systemName: "xmark.circle") ?? UIImage()
        
        qrCode.message = Data(message.utf8)
        
        if let outputImage = qrCode.outputImage {
            if let cgImg = context.createCGImage(outputImage, from: outputImage.extent) {
                return (UIImage(cgImage: cgImg), qrCode.outputImage)
            } else {
                return (xMarkCircle, nil)
            }
        } else {
            return (xMarkCircle, nil)
        }
    }
}

PlaygroundPage.current.setLiveView(QRView())
